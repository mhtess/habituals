var binWidth = 0.5
var minBin = -1
var maxBin = 8

var priorBins = _.range(minBin, maxBin,binWidth)


var nearestPriorBin = function(x, bins){
  return x > _.max(bins) ? 
      _.max(bins) :
      x < _.min(bins) ? 
      _.min(bins) :
      bins[Math.round(((x - _.min(bins))/(_.max(bins) - _.min(bins)))*(bins.length-1))]
}


// var foreach = function(lst, fn) {
//     var foreach_ = function(i) {
//         if (i < lst.leng  th) {
//             fn(lst[i]);
//             foreach_(i + 1);
//         }
//     };
//     foreach_(0);
// };


var shape_alpha = function(gamma,delta){return gamma * delta}
var shape_beta = function(gamma,delta){return (1-gamma) * delta}

var marginalizeERP = function(myERP, label){
    Enumerate(function(){
        var x = sample(myERP)
        return x[label]
    })
}

// var dataFrame = function(d, fieldsToNumerify){
//     return map(
//         function(lst){
//             return _.object(map(function(l){
//                 return _.indexOf(fieldsToNumerify, l[0]) > -1 ? 
//                             [l[0], tjUtils.wpParseFloat(l[1])] : l
//             },
//             _.zip(d[0],lst)
//             ))
//         },
//         d.slice(1))
// }

var avoidEnds = function(response){
    return response==0 ? 0.001 : response==1 ? 0.999 : response
}

var gaussianPMF = function(mu, sigma, bins){
  return map(function(b){return Math.exp(gaussianERP.score([mu, sigma], b))}, bins)
}

var discretizeLogNormalPrior = function(e, mu, sigma){
  Enumerate(function(){
    return flip(e) ? priorBins[discrete(gaussianPMF(mu, sigma, priorBins))] : minBin
  })
}

var discretizeLogNormalPrior2 = function(v, bins){
  var e = v[0]
  var mu = v[1]
  var sigma = v[2]
  Enumerate(function(){
    return flip(e) ? bins[discrete(gaussianPMF(mu, sigma, bins))] : minBin
  })
}

var mix2GaussiansWithDelta = function(e, mix, m1, s1, m2, s2, bins){
  Enumerate(function(){
    return flip(e) ?  flip(mix) ? 
                        bins[discrete(gaussianPMF(m1, s1, bins))] :
                        bins[discrete(gaussianPMF(m2, s2, bins))] : 
                        0
                    // _.min(bins)
  })
}



var HDI = function(samples, credMass){
  var sortedPts = samples.sort()
  var ciIdxInc = Math.ceil(credMass* sortedPts.length)
  var nCIs = sortedPts.length - ciIdxInc
  var ciWidth = map(function(i){
    sortedPts[i + ciIdxInc] - sortedPts[i]
  },_.range(nCIs))
  var i = _.indexOf(ciWidth, _.min(ciWidth))
  return [sortedPts[i], sortedPts[i+ciIdxInc]]
}

var reasonableDiscretization = function(v){
  var e = v[0]
  var mu = v[1]
  var sigma = v[2]
  var ci = HDI(repeat(10000, function(){return gaussian(mu,sigma)}), 0.95)
  var binWidth = (ci[1]-ci[0])/10
  var bins = _.range(ci[0], ci[1], binWidth);
  var finalState =(_.max(bins) > maxBin) ? _.max(bins) : maxBin;
  var stateBins = _.union(bins,[finalState])
  var finalTheta = (_.max(bins) > maxBin) ? 
                      _.max(bins) - binWidth/2 : 
                      maxBin - ((maxBin - _.max(bins)) / 2)
  var thetaBins = _.union(map(function(x) {
    return x + binWidth/2;
  }, bins), [finalTheta]);
  return {stateBins: stateBins, thetaBins: thetaBins}
}


var guessingLink = function(myERP, phi){
    Enumerate(function(){
        var x = flip(1-phi) ? 
                    sample(myERP) :
                    ["habitual","mm"][discrete([0.5,0.5])]
        return x
    })
}

var softmaxSpeaker = function(speakerERP, softmax){
  Enumerate(function(){
      var supp = speakerERP.support()
      var probs = map(function(s){return Math.exp(softmax*speakerERP.score([],s))}, supp)
      var response = supp[discrete(probs)]
      return response
  })
}

var normalize = function(probs){
    return map(function(x){return x/sum(probs)}, probs)
}
